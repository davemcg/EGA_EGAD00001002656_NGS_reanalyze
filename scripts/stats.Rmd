---
title: "Stats on Hets and Homs"
output: html_notebook
---

# Input
Queried the `EGAD00001002656.GATK.PED_EGAD00001002656.gemini.db` gemini database with two queries


```{bash, eval = FALSE}
#biowulf2
sinteractive
module load gemini
cd /data/mcgaugheyd/projects/nei/mcgaughey/EGA_EGAD00001002656_7n/vcf_annotated
# just search once (well, twice)
time gemini query --show-samples --header -q "select * from variants where aaf < 0.05 and filter is NULL AND (aaf_esp_all < 0.01 AND aaf_1kg_all_float < 0.01 AND af_exac_all < 0.01  AND (is_coding=1 OR is_splicing=1)) OR impact_severity='HIGH' OR clinvar_sig LIKE '%patho%'" --gt-filter "(gt_types).(*).(==HOM_ALT).(any)" EGAD00001002656.GATK.PED_EGAD00001002656.gemini.db  > EGAD.homs &
time gemini query --show-samples --header -q "select * from variants where aaf < 0.05 and filter is NULL AND (aaf_esp_all < 0.0001 AND aaf_1kg_all_float < 0.0001 AND af_exac_all < 0.0001  and (is_coding=1 OR is_splicing=1)) OR impact_severity='HIGH' OR clinvar_sig LIKE '%patho%'" --gt-filter "(gt_types).(*).(==HET).(any)" EGAD00001002656.GATK.PED_EGAD00001002656.gemini.db  > EGAD.hets &
```

# How many hets and homs do we have?
## First input data
```{r}
library(tidyverse)
library(ggsci)
library(data.table)
library(ggridges)
# load in data
het <- read_tsv('/Volumes/Arges_NFS/PROJECTS/mcgaughey/EGA_EGAD00001002656_NGS_reanalyze/raw_data/EGAD.hets')
hom <- read_tsv('/Volumes/Arges_NFS/PROJECTS/mcgaughey/EGA_EGAD00001002656_NGS_reanalyze/raw_data/EGAD.homs')
#het <- fread('~/EGAD.hets_0.01')
#hom <- fread('~/EGAD.homs')
```

## Counts
```{r}
# total hom and het
nrow(hom)
nrow(het)
```

## Counts with grouping
```{r}
hom %>% group_by(impact_severity) %>% summarise(count=n())
hom %>% group_by(impact_severity) %>% summarise(count=n())
```

# Reshape
We have a column (hom_alt or het)_samples which has a comma separate list of samples with the genotype. I think we should split this up and get a new row for each sample. 
```{r}
hom_long <- hom %>% 
  mutate(Sample = str_split(hom_alt_samples, ","), Genotype = 'Hom') %>%  # split with str_split to create a list
  unnest(Sample, .drop=F) # unnest will spread the list, creating a row for each entry

het_long <- het %>% 
  mutate(Sample = str_split(het_samples, ","), Genotype = 'Het') %>%  # split with str_split to create a list
  unnest(Sample, .drop=F) # unnest will spread the list, creating a row for each entry


all <- rbind(hom_long, het_long)
```

## Ridges plots of counts of variants grouped by impact_severity and sample
Low is underrepresented because most are filtered out by allele frequency at SQL query
```{r}
hom_long %>% group_by(impact_severity, Sample) %>% summarise(count=n()) %>% mutate(`Impact Severity` = factor(impact_severity, levels = c('LOW','MED','HIGH'))) %>% ggplot(aes(x=count, y=`Impact Severity`, fill=`Impact Severity`)) + geom_density_ridges(scale=10) + theme_minimal() + scale_fill_npg()

het_long %>% group_by(impact_severity, Sample) %>% summarise(count=n()) %>% mutate(`Impact Severity` = factor(impact_severity, levels = c('LOW','MED','HIGH'))) %>% ggplot(aes(x=count, y=`Impact Severity`, fill=`Impact Severity`)) + geom_density_ridges(scale=10) + theme_minimal() + scale_fill_npg()
```
# Load in sample metadata
```{r}
metadata <- readxl::read_excel(path='~/git/EGA_EGAD00001002656_NGS_reanalyze/data/1-s2.0-S0002929716305274-mmc3.xlsx') %>% mutate(Sample=Patient)
metadata
# vep
#vep <- read_tsv('~/git/EGA_EGAD00001002656_NGS_reanalyze/data/vep_metadata.txt') %>% unique()
```

# *Solved* case variants that don't match to gemini search by HGVSc
```{r}
metadata %>% filter((!Variant_HGVSc %in% all$hgvsc) & Status=='Solved'  & Variant_HGVSc!='NA') 
```

# Now try to match by chr pos ref alt
```{r}
var_gen <- metadata %>% filter((!Variant_HGVSc %in% all$hgvsc) & Status=='Solved'  & Variant_HGVSc!='NA') %>% pull(Variant_genomic)

metadata %>% filter(Variant_genomic %in% var_gen) %>% 
  filter(!Variant_genomic %in% 
           (all %>% mutate(Variant_genomic = paste0(chrom, ':', start + 1, ref, '>', alt)) %>% pull(Variant_genomic)))
```

# Function to check gemini database for variants by (rough) position
```{r}
gemini_query <- function(chrom, start) {
  query <- paste0("gemini query --show-samples --header -q 'select chrom, ref, alt, start, end, is_coding, aaf,filter, aaf_esp_all, aaf_1kg_all_float, af_exac_all, impact, impact_severity, clinvar_sig from variants where chrom==\"", chrom, "  and start > ", start-5, " and start < ", start + 5, "' /Volumes/Arges/NGS_data/DNA/gemini_db/EGAD00001002656.GATK.PED_EGAD00001002656.gemini.db")
  #system(query)
  query
}
```

# ID Compound Het
```{r}
sample_gene_comp_het <- metadata %>% filter(Status=='Solved'  & Variant_HGVSc!='NA' & GT=='0/1') %>% group_by(Sample, Gene) %>% summarise(Count=n()) %>% filter(Count>1) 
metadata <- left_join(metadata, sample_gene_comp_het) %>% mutate(Comp_Het_Path = case_when(Count >= 2 ~ 'CH', 
                                                                                           TRUE ~ 'No')) %>% 
  select(-Count)
```
# ML
Label variants as pathogenic
```{r}
all <- all %>% mutate(Status = case_when(hgvsc %in% (metadata %>% filter(Status=='Solved') %>% pull(Variant_HGVSc)) ~ 'Pathogenic',
                                         TRUE ~ 'NotPathogenic')) %>% 
  mutate(Complicated_Status = case_when(hgvsc %in% (metadata %>% filter(Comp_Het_Path == 'Yes') %>% pull(Variant_HGVSc)) ~ 'Comp_Het',
                                        hgvsc %in% (metadata %>% filter(Status=='Solved' & GT=='0/1') %>% pull(Variant_HGVSc)) ~ 'AD',
                                        hgvsc %in% (metadata %>% filter(Status=='Solved' & GT=='1/1') %>% pull(Variant_HGVSc)) ~ 'AR',
                                        
                               TRUE ~ 'Not Pathogenic'))
```

## Subsample
Split in training / testing

Group by:
- Status (solved /not solved) <- drop Partially solved
- Genotype (Hom / Het)
- Comp Het (two Hets in one gene)

Subsample the non-pathogenic to be 10x the size of the pathogenic to reduce class imbalance
```{r}

all_PATH <- all %>% 
  select(variant_id, filter, type, call_rate, num_hom_ref, num_het, num_hom_alt, aaf, is_exonic, is_coding, is_lof, is_splicing, impact, impact_so, impact_severity, polyphen_score, sift_score, aaf_1kg_afr_float:an_exac_sas, max_aaf_all, pli, pnull, precessive, phylop_100way, canonical, cadd_phred, Genotype, Status, Complicated_Status) %>% 
  filter(Status=='Pathogenic') %>% 
  unique()
all_NOT_PATH <- all %>% 
 select(variant_id, filter, type, call_rate, num_hom_ref, num_het, num_hom_alt, aaf, is_exonic, is_coding, is_lof, is_splicing, impact, impact_so, impact_severity, polyphen_score, sift_score, aaf_1kg_afr_float:an_exac_sas, max_aaf_all, pli, pnull, precessive, phylop_100way, canonical, cadd_phred, Genotype, Status, Complicated_Status) %>% 
  filter(Status=='NotPathogenic') %>% 
  unique()
 
# multiply path by 10x with duplications
#all_PATH_10X <- bind_rows(replicate(10, all_PATH, simplify = FALSE))
all_PATH_10X <- all_PATH
# cut down pathogenic to 10x of path
set.seed(115470)
all_NOT_PATH_CUT <- all_NOT_PATH #%>% sample_n(nrow(all_PATH_10X) * 15)

ML_set <- rbind(all_PATH_10X, all_NOT_PATH_CUT)

#cadd phred has NA
ML_set[is.na(ML_set)] <- 0
# convert chr to factor
ML_set <- ML_set %>%  mutate_each_( funs(as.factor(.)), names( .[,sapply(., is.character)] ))
# Fix numeric that are fctr
ML_set$polyphen_score <- as.numeric(ML_set$polyphen_score)
ML_set$sift_score <- as.numeric(ML_set$sift_score)
ML_set$adj_exp_lof <- as.numeric(ML_set$adj_exp_lof)
ML_set$adj_exp_mis <- as.numeric(ML_set$adj_exp_mis)
ML_set$adj_exp_syn <- as.numeric(ML_set$adj_exp_syn)
ML_set$pli <- as.numeric(ML_set$pli)
ML_set$pnull <- as.numeric(ML_set$pnull)
ML_set$precessive <- as.numeric(ML_set$precessive)
ML_set$phylop_100way <- as.numeric(ML_set$phylop_100way)
ML_set$Status <- factor(ML_set$Status, levels=c('Pathogenic','NotPathogenic'))


```

## One hot encoding (Dummy variables)
Turn categorical factors into variables

Many ML algorithms can't handle factor

You can feed this into the `Train and Test sets` section below if you are using something like a GLM or NN. 
```{r}
temp <- ML_set %>% dplyr::select(-filter, -Status, -Complicated_Status)
dmy <- dummyVars(" ~ .", data = temp, fullRank=T)
ML_set_dummy <- data.frame(predict(dmy, newdata = temp))
ML_set_dummy <- ML_set_dummy %>% mutate(Status = ML_set$Status, Complicated_Status = ML_set$Complicated_Status)
```

## Train and Test sets
```{r}
set.seed(115470)
train_set <- ML_set %>% 
  group_by(Status, Complicated_Status) %>% 
  sample_frac(0.5) %>% ungroup()

test_set <- ML_set %>% 
  filter(!variant_id %in% train_set$variant_id)
```

## Recipe
skip for now
```{r, eval=FALSE}
library(caret)
train_setR <- train_set %>% dplyr::select(-Complicated_Status, -variant_id)
rec_obj <- recipe(Status ~ ., data = train_setR)
```



## RF
```{r}
library(caret)
#library(plotROC)
fitControl <- trainControl(## 5-fold CV
  method = "repeatedcv",
  number = 5,
  repeats = 5, 
  classProbs=T,
  savePredictions = T,
  summaryFunction = prSummary,
  allowParallel = T)


set.seed(825)
rfFit <- caret::train(x=train_set %>% dplyr::select(-variant_id, -Status, -Complicated_Status) %>% data.frame(), 
                      y = train_set$Status, 
                      preProcess = c("scale", "center"),
                      method = "rf", 
                      trControl = fitControl)
rfFit
confusionMatrix(data = rfFit$pred$pred, reference = rfFit$pred$obs, mode='prec_recall')
# change cutoff
confusionMatrix(data = rfFit$pred %>% mutate(pred2 = case_when(Pathogenic > 0.2 ~ 'Pathogenic', TRUE ~ 'NotPathogenic')) %>% pull(pred2), reference = rfFit$pred$obs)

randomForest::varImpPlot(rfFit_tissue$finalModel)
selectedIndices <- rfFit$pred$mtry == rfFit_tissue$bestTune[1,] #26

g <- ggplot(rfFit$pred[selectedIndices, ], aes(m=Pathogenic, d=factor(obs, levels=c('Pathogenic','NotPathogenic')))) + 
  geom_roc(n.cuts=0) + 
  coord_equal() +
  style_roc()

g + annotate("text", x=0.75, y=0.25, label=paste("AUC =", round((calc_auc(g))$AUC, 4)))
```